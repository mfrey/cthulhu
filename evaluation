#!/usr/bin/env python2.7

import os
import sys
import numpy as np

#import table
from math import sqrt

import matplotlib
#matplotlib.use('Agg')
import matplotlib.pyplot as plt

import pylab

from scalarfileparser import ScalarFileParser

import json
import pprint

def main():
    if len(sys.argv) != 2:
        sys.exit(1)

    with open(sys.argv[1]) as configuration_file:
        configuration = json.load(configuration_file)

    results = {}
    # get the directory to parse from the json file
    directory = configuration["directory"]
    # same goes for the title, xlabel, and ylabel of the plot
    title  = configuration["plot"]["title"]
    xlabel = configuration["plot"]["xlabel"]
    ylabel = configuration["plot"]["ylabel"]
    # set the filename of the plot
    current_filename = configuration["plot"]["file"]

    # get the data
    for result_file in os.listdir(directory):
        if result_file.endswith(".sca"):
            parser = ScalarFileParser(directory + result_file)
            data = parser.read()
            offset = float(data.parameters['offset'])

            if offset not in results:
                results[offset] = {}

            for node in data.nodes.keys():
                if node not in results[offset]:
                    results[offset][node] = []

            # compute the packet reception rate = received packets/sent packets
            sent_packets = float(data.nodes['2']['sent:count'])
            arrived_packets = float(data.nodes['0']['arrival:count'])
            packet_reception_rate = float(arrived_packets/sent_packets)
            results[offset]['0'].append(packet_reception_rate)

            sent_packets = float(data.nodes['3']['sent:count'])
            arrived_packets = float(data.nodes['1']['arrival:count'])
            packet_reception_rate = float(arrived_packets/sent_packets)
            results[offset]['1'].append(packet_reception_rate)

    # sort the offsets
    offsets = sorted(results.keys(), key=float)
    # define our coordinators
    nodes = ['0','1']

    # we are going to have a plot with broken axes
    figure, (axis, axis2) = plt.subplots(1, 2, sharey=True)

    # in milimeters
    textwidth = 183.0
    # convert textwdith to inches
    inches_per_mm =  0.039370
    # get aesthetic ratio
    golden_mean = (sqrt(5)-1.0)/2.0 
    # width in inches
    fig_width = textwidth * inches_per_mm
    # height in inches
    fig_height = fig_width * golden_mean       
    fig_size = [fig_width,fig_height*0.5]

    figure.set_size_inches(fig_width,fig_height*0.5)
    plt.set_cmap('cubehelix')

    # update the parameters
    params = {'backend': 'ps', 
      'axes.labelsize': 8, 
      'font.size': 8, 
      'legend.fontsize': 8, 
      'xtick.labelsize': 6, 
      'ytick.labelsize': 6, 
      'text.usetex': True, 
      'figure.figsize': fig_size} 
    pylab.rcParams.update(params)

    # plot the data
    for node in nodes:
        average = []
        minimum = []
        maximum = []

        for offset in offsets:
             average_per_offset = np.average(results[offset][node])
             average.append(average_per_offset)
             minimum_per_offset = np.amin(results[offset][node])
             minimum.append(minimum_per_offset)
             maximum_per_offset = np.amax(results[offset][node])
             maximum.append(maximum_per_offset)

        # let's set the network type for the labels
        network_type = configuration["network-properties"][node] + "$_{" + node + "}$"

        plt.xticks(np.arange(min(offsets), max(offsets)+0.05, 0.10))
        plt.yticks(np.arange(min(minimum), max(maximum)+0.05, 0.20))

        base_line, = axis.plot(offsets, average, lw=2, label=network_type)
        axis.fill_between(offsets, maximum, minimum, color=base_line.get_color(), alpha=0.5)

        base_line, = axis2.plot(offsets, average, lw=2, label=network_type)
        axis2.fill_between(offsets, maximum, minimum, color=base_line.get_color(), alpha=0.5)

        axis.set_xlim(0,.25) 
        axis2.set_xlim(.75,1.) 

        axis.spines['right'].set_visible(False)
        axis2.spines['left'].set_visible(False)
        axis.yaxis.tick_left()
        axis.tick_params(labeltop='off') 
        axis2.yaxis.tick_right()

    plt.subplots_adjust(wspace=0.10, bottom=0.14)
    d = .010

    kwargs = dict(transform=axis.transAxes, color='k', clip_on=False)
    axis.plot((1-d,1+d),(-d,+d), **kwargs) # top-left diagonal
    axis.plot((1-d,1+d),(1-d,1+d), **kwargs) # bottom-left diagonal

    kwargs.update(transform=axis2.transAxes) # switch to the bottom axes
    axis2.plot((-d,d),(-d,+d), **kwargs) # top-right diagonal
    axis2.plot((-d,d),(1-d,1+d), **kwargs) # bottom-right diagonal

    # enable grid
    axis.grid()
    axis2.grid()

    # title
    figure.suptitle(title)  
    # labels
    figure.text(0.5, 0.04, xlabel, ha='center', va='center')
    figure.text(0.06, 0.5, ylabel, ha='center', va='center', rotation='vertical')

    # put the legend inside the figure
    # plt.legend(loc=0)
    plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
    # put the legend above the figure (currently only above one axis)
    #plt.legend(bbox_to_anchor=(0., 1.02, 1., .102), loc=3, ncol=2, mode="expand", borderaxespad=0.)

    figure.savefig(current_filename)
    plt.close()
 
if __name__ == "__main__":
    main()

#!/usr/bin/env python2.7

import os
import numpy as np

import table
from math import sqrt

import matplotlib
#matplotlib.use('Agg')
import matplotlib.pyplot as plt

import pylab

from scalarfileparser import ScalarFileParser

import json

def main():
    results = {}
    directory = "/home/frey/Desktop/Projekte/SemInt/Castalia-master/Castalia/Simulations/802154_interference/results/"

    # get the data
    for result_file in os.listdir(directory):
        if result_file.endswith(".sca"):
            parser = ScalarFileParser(directory + result_file)
            data = parser.read()
            offset = float(data.parameters['offset'])

            if offset not in results:
                results[offset] = {}

            for node in data.nodes.keys():
                if node not in results[offset]:
                    results[offset][node] = []

            sent_packets = float(data.nodes['2']['sent:count'])
            arrived_packets = float(data.nodes['0']['arrival:count'])
            packet_reception_rate = float(arrived_packets/sent_packets)
            results[offset]['0'].append(packet_reception_rate)

            sent_packets = float(data.nodes['3']['sent:count'])
            arrived_packets = float(data.nodes['1']['arrival:count'])
            packet_reception_rate = float(arrived_packets/sent_packets)
            results[offset]['1'].append(packet_reception_rate)

    offsets = sorted(results.keys(), key=float)
    nodes = ['0','1']

    title = "Packet Reception Rate vs. Beacon Offset"
    xlabel = "Beacon Offset"
    ylabel = "Packet Reception Rate"
    current_filename = "meh.pdf"

    figure, (axis, axis2) = plt.subplots(1, 2, sharey=True)

    # in milimeters
    textwidth = 183.0
    # convert textwdith to inches
    inches_per_mm =  0.039370
    # get aesthetic ratio
    golden_mean = (sqrt(5)-1.0)/2.0 
    # width in inches
    fig_width = textwidth * inches_per_mm
    # height in inches
    fig_height = fig_width * golden_mean       
    fig_size = [fig_width,fig_height*0.5]

    figure.set_size_inches(fig_width,fig_height*0.5)
    plt.set_cmap('cubehelix')

    # update the parameters
    params = {'backend': 'ps', 
      'axes.labelsize': 8, 
      'font.size': 8, 
      'legend.fontsize': 8, 
      'xtick.labelsize': 6, 
      'ytick.labelsize': 6, 
      'text.usetex': True, 
      'figure.figsize': fig_size} 
    pylab.rcParams.update(params)

    # plot the data
    for node in nodes:
        average = []
        minimum = []
        maximum = []

        for offset in offsets:
             average_per_offset = np.average(results[offset][node])
             average.append(average_per_offset)
             minimum_per_offset = np.amin(results[offset][node])
             minimum.append(minimum_per_offset)
             maximum_per_offset = np.amax(results[offset][node])
             maximum.append(maximum_per_offset)

        network_type = ""

        if node == '0':
            #network_type = "csma$_{0}$"
            network_type = "gts$_{0}$"
        else:
            #network_type = "csma$_{1}$"
            network_type = "gts$_{1}$"

        plt.xticks(np.arange(min(offsets), max(offsets)+0.05, 0.10))
        plt.yticks(np.arange(min(minimum), max(maximum)+0.05, 0.20))

        base_line, = axis.plot(offsets, average, lw=2, label=network_type)
        axis.fill_between(offsets, maximum, minimum, color=base_line.get_color(), alpha=0.5)

        base_line, = axis2.plot(offsets, average, lw=2, label=network_type)
        axis2.fill_between(offsets, maximum, minimum, color=base_line.get_color(), alpha=0.5)

        axis.set_xlim(0,.25) 
        axis2.set_xlim(.75,1.) 

        axis.spines['right'].set_visible(False)
        axis2.spines['left'].set_visible(False)
        axis.yaxis.tick_left()
        axis.tick_params(labeltop='off') 
        axis2.yaxis.tick_right()

    plt.subplots_adjust(wspace=0.10, bottom=0.14)
    d = .010

    kwargs = dict(transform=axis.transAxes, color='k', clip_on=False)
    axis.plot((1-d,1+d),(-d,+d), **kwargs) # top-left diagonal
    axis.plot((1-d,1+d),(1-d,1+d), **kwargs) # bottom-left diagonal

    kwargs.update(transform=axis2.transAxes) # switch to the bottom axes
    axis2.plot((-d,d),(-d,+d), **kwargs) # top-right diagonal
    axis2.plot((-d,d),(1-d,1+d), **kwargs) # bottom-right diagonal

    # enable grid
    axis.grid()
    axis2.grid()

    # title
    figure.suptitle(title)  
    # labels
    figure.text(0.5, 0.04, xlabel, ha='center', va='center')
    figure.text(0.06, 0.5, ylabel, ha='center', va='center', rotation='vertical')

    # put the legend inside the figure
    # plt.legend(loc=0)
    plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
    # put the legend above the figure (currently only above one axis)
    #plt.legend(bbox_to_anchor=(0., 1.02, 1., .102), loc=3, ncol=2, mode="expand", borderaxespad=0.)

    figure.savefig(current_filename)
    plt.close()
 
if __name__ == "__main__":
    main()
